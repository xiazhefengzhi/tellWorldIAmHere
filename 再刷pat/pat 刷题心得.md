### 再考一次pat

```
如果人生没有重来，那就好好过好这一次
```

```
 不畏过去，不念将来，为生命努力这一次
```

```
本代码 主要效仿柳神
```

###   PAT 1-20 

## **1001. A+B Format (20).cpp**

```
1. string s = to_string(a + b); // 把int 的数值进行相加 结果用 string 保留下来
2. 得到的结果保留 - 符号 ，使用'-'  进行特判 处理 输出的结果
3. 每隔3位进行一次输出操作 使用条件 (i+1)%3==len%3, 如果不足三位不进行 输出 &&i!=len-1
  if ((i + 1) % 3 == len % 3 && i != len - 1) //  进行控制 每3位进行一个，输出
  
 - 从终点出发 进行输出结果的操作 len-1 位  一定输出结果的位置 ，再向前移动 k个位置 x=len-1-m*k(所以 这就是判断条件的由来) 
 
```

### **1002. A+B for Polynomials (25).cpp**

```
1. 注意数据的类型  使用float 进行浮点数的存储
2. 进行数组的初始化操作  float c[1001] = {0};
3. 不进行 数据的实时存储 ， 把数据和c数组直接进行操作，得到的数据 直接按照指定逻辑输出 
4. 判断数据是否为 0 使用 ==0.0 输出数据的时候 使用 .1f
 进行流式计算 
```

## **1003. Emergency (25) .cpp**

```
1.    初步定义了一下问题是什么
 求图的最短路径问题 知道起点终点 。寻找最最短路，同时 所使用的权值最大
2. 求最短路问题的  解题思路  首先定义解决问题的数据结构
 e[510][510]// 这是 表示节点的边，同时代表路径是否可到达
 weight【510】// 这个节点的权值 
 dis[510]  //表示节点的最短路,所以就
 num[510] //  路径的条数
 w[510]//  实际节点的权值
 visit[510] //  表示节点是否进行过初始化操作
 
 3. 1. 第一步初始化
 
 fill(e[0], e[0] + 510 * 510, inf); // 填充路径不可达到
 
2. 进行 进行搜索起点的赋值
  dis[c1] = 0;
    w[c1] = weight[c1];
    num[c1] = 1;
 3.  进行dis的搜索 值得操作
 4. 进行结果的输出
```

 最短路算法的简单说明

```
 有一个图,需要知道从一个节点出发到达另一个节点的最短路径为多少.这个时候需要做的就是
 
 进行 循环  找到 
 1. 找到当前节点能够到达的路径 , 并 统计 所有路径的大小  ，进行 相加操作 存放到dis[j]中，并 标记 访问标志 这个节点已经进行过访问操作，（因为 就算要达到 不是最大的路径 ，也是根据 当前路径出发 ，不得的进行搜索哪一条路比当前路径更短 ，然后的到的）
 2. 选出 一个不能再小的节点  以这个节点作为出发点 ，不断的进行 扩展知道可以达到 最短路
 3. 当没有通路可以到达或者 所有的节点都访问了就 跳出循环 
 
```

```
思考  // 对比  num[v] = num[v] + num[u];  和 num[v]++的差异

进行路径的增加的时候 不是 增加了一条 路径 而是 增加了 新加节点它的路径之和 即num[u]
```

```
 自己手写代码 注意的点 
    1.scanf("%d",&weight[i]); //可以直接对数组的元素进行赋值操作
    2.     fill(e[0],e[0]+510*510,inf);  二维数据的赋值 使用 e[0] 而不是e[0][0]
    3.    int a,b,c;    获得 进行 临时数据的变量  v 进行循环的变量
    4. 使用cout 进行输出显示 判断自己的代码是否有问题
    
```



###  **1004** **Counting Leaves** 

```
  题目分析 ： 这是一个二叉树的层次 ，用于判断二叉树每一层叶子节点的个数  ，使用 队列进行判断比较合适 //   柳神 不愧是柳神 ，并没有使用队列 进行求解 而是 进行了dfs的搜索操作 ，我对下一个节点 进行搜索 
  
   节点
   	* 有下一级节点 进行 搜索操作 
    * 没有下一级节点 当场 返回  在所在层数进行++ 处理
    可以参考学习的点
   1. 使用vector<int>v[100]  这样的数据结构 来表示 某个节点存在 很多的 叶子节点 ，然后可以对叶子节点进行搜索处理
   节点的添加 操作 
        v[node].push_back(c);  //多么怀念的方法 , 仿佛回到了3年前的那个少年
        
   2. dfs 搜索处理
    1 . 明确返回的边界条件 即 没有下一个节点
    v[index].size() == 0 
     返回时的输出值book[depth]++ 处理
         maxdepth = max(maxdepth, depth)  // 获得最大的层数
     2. 进行递归到下一层的处理  
        for(int i = 0; i < v[index].size(); i++)
        dfs(v[index][i], depth + 1);
      3. 输入和输出  ，定义数组
 
```



###  **1005** **Spell It Right**

```
问题是什么： 使用map 进行映射 输出英文

1. 使用to_string 进行调试 ,手写to_String有问题 ，就目前本地使用的时候试一下
2. 进行映射的方式不是使用map 而是 使用 string 数组 ，对应数字对应相应的英文
   //string arr[10] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
3.  进行string的答应操作 使用 s.c_str() 才能进行打印输出操作


```

###   **1006** **Sign In and Sign Out**  

```
问题是什么 :  这是一道结构体排序的题目  ,找出排序方式按时间的最大值和最小值
//并没有使用结构体保留数据，而是简单的进行流式处理，每次的结果进行统计，如果比最大值大保留，比最小值小进行保留
1. INT_MAX INT_MIN   进行最大值的读取和最小值的读取
int n, minn = INT_MAX, maxn = INT_MIN;
2.     scanf("%d:%d:%d %d:%d:%d", &h1, &m1, &s1, &h2, &m2, &s2);
用6个 int的数据 进行 时间的读取 ，最进行求和 进行 流式数据比较
3.   cout << unlocked << " " << locked;
使用String的输出 用cout
```

###  **1007** **Maximum Subsequence Sum** 

```
非常经典的连续数字的最大和问题
一次for 循环 如果结果小于 0就 重新开始计算
 //  一开始以为这一题处理起来很简单 ，实际上处理的时间超过了一个小时 。。。。 有几个细节值得注意吧
 1. vector<int>v(n);  进行赋值操作的时候直接 指定地址进行赋值 ，不然 读取数据会进行动态扩容
       scanf("%d", &v[i]); //  不是 使用 v.push_back
 2. max进行赋值的时候使用 -1 
 3. 进行 条件的使用的时候 ，注意在哪一步对条件进行了 更改 ，else if 和 if的关系判断不正确导致了 没有进行正确的数据处理
 4. 进行 规范化变量命名的重要性  leftindex ，rightindex ，sum,temp,tempindex 临时的节点
 
```

###   **1008** **Elevator** 

```
哈哈，这一题我可以使用流式数据处理了
每次 记录一个值和上一个值得差别，比较是大还是小 ，进行数据的输出
 // 水题

```

###  **1009** **Product of Polynomials** 

```
思路: 使用两个数组来保存数据结构 arr[1001] 作为乘法处理的式子，第二次的结果与第一次的结果进行运算，算出结果保留到最终的结果集中，
1.  double b, arr[1001] = {0.0}, ans[2001] = {0.0};  使用double 
2. 用for循环进行统计所进行的系数不为0的数据的数量
3. 进行结果输出


```

###  **1010** **Radix** 

```
1.  进行 进制转换处理


```

