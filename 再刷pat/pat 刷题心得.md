### 再考一次pat

```
如果人生没有重来，那就好好过好这一次
```

```
 不畏过去，不念将来，为生命努力这一次
```

```
本代码 主要效仿柳神
```

###   PAT 1-20 

## **1001. A+B Format (20).cpp**

```
1. string s = to_string(a + b); // 把int 的数值进行相加 结果用 string 保留下来
2. 得到的结果保留 - 符号 ，使用'-'  进行特判 处理 输出的结果
3. 每隔3位进行一次输出操作 使用条件 (i+1)%3==len%3, 如果不足三位不进行 输出 &&i!=len-1
  if ((i + 1) % 3 == len % 3 && i != len - 1) //  进行控制 每3位进行一个，输出
  
 - 从终点出发 进行输出结果的操作 len-1 位  一定输出结果的位置 ，再向前移动 k个位置 x=len-1-m*k(所以 这就是判断条件的由来) 
 
```

### **1002. A+B for Polynomials (25).cpp**

```
1. 注意数据的类型  使用float 进行浮点数的存储
2. 进行数组的初始化操作  float c[1001] = {0};
3. 不进行 数据的实时存储 ， 把数据和c数组直接进行操作，得到的数据 直接按照指定逻辑输出 
4. 判断数据是否为 0 使用 ==0.0 输出数据的时候 使用 .1f
 进行流式计算 
```

## **1003. Emergency (25) .cpp**

```
1.    初步定义了一下问题是什么
 求图的最短路径问题 知道起点终点 。寻找最最短路，同时 所使用的权值最大
2. 求最短路问题的  解题思路  首先定义解决问题的数据结构
 e[510][510]// 这是 表示节点的边，同时代表路径是否可到达
 weight【510】// 这个节点的权值 
 dis[510]  //表示节点的最短路,所以就
 num[510] //  路径的条数
 w[510]//  实际节点的权值
 visit[510] //  表示节点是否进行过初始化操作
 
 3. 1. 第一步初始化
 
 fill(e[0], e[0] + 510 * 510, inf); // 填充路径不可达到
 
2. 进行 进行搜索起点的赋值
  dis[c1] = 0;
    w[c1] = weight[c1];
    num[c1] = 1;
 3.  进行dis的搜索 值得操作
 4. 进行结果的输出
```

 最短路算法的简单说明

```
 有一个图,需要知道从一个节点出发到达另一个节点的最短路径为多少.这个时候需要做的就是
 
 进行 循环  找到 
 1. 找到当前节点能够到达的路径 , 并 统计 所有路径的大小  ，进行 相加操作 存放到dis[j]中，并 标记 访问标志 这个节点已经进行过访问操作，（因为 就算要达到 不是最大的路径 ，也是根据 当前路径出发 ，不得的进行搜索哪一条路比当前路径更短 ，然后的到的）
 2. 选出 一个不能再小的节点  以这个节点作为出发点 ，不断的进行 扩展知道可以达到 最短路
 3. 当没有通路可以到达或者 所有的节点都访问了就 跳出循环 
 
```

```
思考  // 对比  num[v] = num[v] + num[u];  和 num[v]++的差异

进行路径的增加的时候 不是 增加了一条 路径 而是 增加了 新家节点他的路径之和 即num[u]
```

```
 自己手写代码 注意的点 
    1.scanf("%d",&weight[i]); //可以直接对数组的元素进行赋值操作
    2.     fill(e[0],e[0]+510*510,inf);  二维数据的赋值 使用 e[0] 而不是e[0][0]
    3.    int a,b,c;    获得 进行 临时数据的变量  v 进行循环的变量
    4. 使用cout 进行输出显示 判断自己的代码是否有问题
    
```



###  **1004** **Counting Leaves** 

```
  题目分析 ： 这是一个二叉树的层次 ，用于判断二叉树每一层叶子节点的个数  ，使用 队列进行判断比较合适
```

