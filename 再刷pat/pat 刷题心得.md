### 再考一次pat

```
如果人生没有重来，那就好好过好这一次
```

```
 不畏过去，不念将来，为生命努力这一次
```

```
本代码 主要效仿柳神
```

###   PAT 1-20 

## **1001. A+B Format (20).cpp**

```
1. string s = to_string(a + b); // 把int 的数值进行相加 结果用 string 保留下来
2. 得到的结果保留 - 符号 ，使用'-'  进行特判 处理 输出的结果
3. 每隔3位进行一次输出操作 使用条件 (i+1)%3==len%3, 如果不足三位不进行 输出 &&i!=len-1
  if ((i + 1) % 3 == len % 3 && i != len - 1) //  进行控制 每3位进行一个，输出
  
 - 从终点出发 进行输出结果的操作 len-1 位  一定输出结果的位置 ，再向前移动 k个位置 x=len-1-m*k(所以 这就是判断条件的由来) 
 
```

### **1002. A+B for Polynomials (25).cpp**

```
1. 注意数据的类型  使用float 进行浮点数的存储
2. 进行数组的初始化操作  float c[1001] = {0};
3. 不进行 数据的实时存储 ， 把数据和c数组直接进行操作，得到的数据 直接按照指定逻辑输出 
4. 判断数据是否为 0 使用 ==0.0 输出数据的时候 使用 .1f
 进行流式计算 
```

## **1003. Emergency (25) .cpp**

```
1.    初步定义了一下问题是什么
 求图的最短路径问题 知道起点终点 。寻找最最短路，同时 所使用的权值最大
2. 求最短路问题的  解题思路  首先定义解决问题的数据结构
 e[510][510]// 这是 表示节点的边，同时代表路径是否可到达
 weight【510】// 这个节点的权值 
 dis[510]  //表示节点的最短路,所以就
 num[510] //  路径的条数
 w[510]//  实际节点的权值
 visit[510] //  表示节点是否进行过初始化操作
 
 3. 1. 第一步初始化
 
 fill(e[0], e[0] + 510 * 510, inf); // 填充路径不可达到
 
2. 进行 进行搜索起点的赋值
  dis[c1] = 0;
    w[c1] = weight[c1];
    num[c1] = 1;
 3.  进行dis的搜索 值得操作
 4. 进行结果的输出
```

 最短路算法的简单说明

```
 有一个图,需要知道从一个节点出发到达另一个节点的最短路径为多少.这个时候需要做的就是
 
 进行 循环  找到 
 1. 找到当前节点能够到达的路径 , 并 统计 所有路径的大小  ，进行 相加操作 存放到dis[j]中，并 标记 访问标志 这个节点已经进行过访问操作，（因为 就算要达到 不是最大的路径 ，也是根据 当前路径出发 ，不得的进行搜索哪一条路比当前路径更短 ，然后的到的）
 2. 选出 一个不能再小的节点  以这个节点作为出发点 ，不断的进行 扩展知道可以达到 最短路
 3. 当没有通路可以到达或者 所有的节点都访问了就 跳出循环 
 
```

```
思考  // 对比  num[v] = num[v] + num[u];  和 num[v]++的差异

进行路径的增加的时候 不是 增加了一条 路径 而是 增加了 新加节点它的路径之和 即num[u]
```

```
 自己手写代码 注意的点 
    1.scanf("%d",&weight[i]); //可以直接对数组的元素进行赋值操作
    2.     fill(e[0],e[0]+510*510,inf);  二维数据的赋值 使用 e[0] 而不是e[0][0]
    3.    int a,b,c;    获得 进行 临时数据的变量  v 进行循环的变量
    4. 使用cout 进行输出显示 判断自己的代码是否有问题
    
```



###  **1004** **Counting Leaves** 

```
  题目分析 ： 这是一个二叉树的层次 ，用于判断二叉树每一层叶子节点的个数  ，使用 队列进行判断比较合适 //   柳神 不愧是柳神 ，并没有使用队列 进行求解 而是 进行了dfs的搜索操作 ，我对下一个节点 进行搜索 
  
   节点
   	* 有下一级节点 进行 搜索操作 
    * 没有下一级节点 当场 返回  在所在层数进行++ 处理
    可以参考学习的点
   1. 使用vector<int>v[100]  这样的数据结构 来表示 某个节点存在 很多的 叶子节点 ，然后可以对叶子节点进行搜索处理
   节点的添加 操作 
        v[node].push_back(c);  //多么怀念的方法 , 仿佛回到了3年前的那个少年
        
   2. dfs 搜索处理
    1 . 明确返回的边界条件 即 没有下一个节点
    v[index].size() == 0 
     返回时的输出值book[depth]++ 处理
         maxdepth = max(maxdepth, depth)  // 获得最大的层数
     2. 进行递归到下一层的处理  
        for(int i = 0; i < v[index].size(); i++)
        dfs(v[index][i], depth + 1);
      3. 输入和输出  ，定义数组
 
```



###  **1005** **Spell It Right**

```
问题是什么： 使用map 进行映射 输出英文

1. 使用to_string 进行调试 ,手写to_String有问题 ，就目前本地使用的时候试一下
2. 进行映射的方式不是使用map 而是 使用 string 数组 ，对应数字对应相应的英文
   //string arr[10] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
3.  进行string的答应操作 使用 s.c_str() 才能进行打印输出操作


```

###   **1006** **Sign In and Sign Out**  

```
问题是什么 :  这是一道结构体排序的题目  ,找出排序方式按时间的最大值和最小值
//并没有使用结构体保留数据，而是简单的进行流式处理，每次的结果进行统计，如果比最大值大保留，比最小值小进行保留
1. INT_MAX INT_MIN   进行最大值的读取和最小值的读取
int n, minn = INT_MAX, maxn = INT_MIN;
2.     scanf("%d:%d:%d %d:%d:%d", &h1, &m1, &s1, &h2, &m2, &s2);
用6个 int的数据 进行 时间的读取 ，最进行求和 进行 流式数据比较
3.   cout << unlocked << " " << locked;
使用String的输出 用cout
```

###  **1007** **Maximum Subsequence Sum** 

```
非常经典的连续数字的最大和问题
一次for 循环 如果结果小于 0就 重新开始计算
 //  一开始以为这一题处理起来很简单 ，实际上处理的时间超过了一个小时 。。。。 有几个细节值得注意吧
 1. vector<int>v(n);  进行赋值操作的时候直接 指定地址进行赋值 ，不然 读取数据会进行动态扩容
       scanf("%d", &v[i]); //  不是 使用 v.push_back
 2. max进行赋值的时候使用 -1 
 3. 进行 条件的使用的时候 ，注意在哪一步对条件进行了 更改 ，else if 和 if的关系判断不正确导致了 没有进行正确的数据处理
 4. 进行 规范化变量命名的重要性  leftindex ，rightindex ，sum,temp,tempindex 临时的节点
 
```

###   **1008** **Elevator** 

```
哈哈，这一题我可以使用流式数据处理了
每次 记录一个值和上一个值得差别，比较是大还是小 ，进行数据的输出
 // 水题

```

###  **1009** **Product of Polynomials** 

```
思路: 使用两个数组来保存数据结构 arr[1001] 作为乘法处理的式子，第二次的结果与第一次的结果进行运算，算出结果保留到最终的结果集中，
1.  double b, arr[1001] = {0.0}, ans[2001] = {0.0};  使用double 
2. 用for循环进行统计所进行的系数不为0的数据的数量
3. 进行结果输出


```

###  **1010** **Radix** 

```
思路 : 制转换
section1 convert
1.for (auto it = n.rbegin(); it != n.rend(); it++)  // 进行string的倒序输出
2. sum += temp * pow(radix, index++); //  进行乘以一定数量的指数幂
3. 进行进制转化的结果返回 
section2  search 
1. 找到最大的元素 char it = *max_element(n.begin(), n.end());
2. 二分查找 
 while (low <= high) {
        long long mid = (low + high) / 2;
        long long t = convert(n, mid);
        if (t < 0 || t > num) high = mid - 1;
        else if (t == num) return mid;
        else low = mid + 1;
    }
  3. 返回对应的结果
  section3  变量的命名和输入输出数据的处理 
  1. 使用 long long 的数据类型
2. 简单的if else  使用3目运算符进行取代
```

###  **1011** **World Cup Betting** 

```
思路: 找到对应的路径的各个节点的最大值 ，带入数据
1. 使用3次流式输入 避免数据存储和多进行的for循环
2. .2f 或者有乘法的运算使用double 进行数据的存储操作
3. char c[4] = {"WTL"};  // 对应映射的结果进行输出

```

###  **1012** **The Best Rank** 

```
 进行 排序获得 各自对应成绩的最大值 ，如果最好的成绩是相同的，输出优先级较高的
 //  使用结构体对排序的操作进行处理
 1. 排序？？使用 自定义的全局变量 ，对数组中的排序规则进行改变
 sorce[flag]; 可以进行判刑规则的扩展
 2.   进行全局 定义数组 还是 n规模的数据进行固定 数组排序操作，然后添加查找映射关系
  &stu[i].id  //  不是使用stu[id] ，使用 visit[id] 来进行对应的 i 的数据查找操作,减少进行排序时的比较规模
 3.bool cmp1(node a, node b) {return a.score[flag] > b.score[flag];}
 排序的规则
 4.struct node {
    int id, best;
    int score[4], rank[4];
}stu[2005];
//  使用的结构体
5. char c[5] = {'A', 'C', 'M', 'E'}; // 获得输出的 对应映射类型  ，用上面的方式更快
6.stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; // 对int的数据进行四舍五入  
```

###  **1013** **Battle Over Cities** 

```
 进行节点的删除操作，获得孤立的节点的数量 
  进行节点的删除查询是否所有的节点都可以访问到的dfs搜索问题
 // 目前我是这么理解的
 本题的难点在于使用visit 的dfs 搜索 ，进行搜索操作的搜索边界在哪里，如何从上一步搜索到达下一步搜索, 节点不可访问的确定
 1.   fill(visit, visit + 1010, false);  进行清空操作
 2. void dfs(int node) {
    // 实际的搜索操作
    visit[node] = true;
    for(int i = 1; i <= n; i++) {
            //对没有进行标记过的节点进行搜索操作
        if(visit[i] == false && v[node][i] == 1)
            dfs(i);
    }
}
dfs 操作处理
 
```

###  **1014** **Waiting in Line** 

```
结构体进行数据的模拟操作   并计算出每一个个体所花的时间

  思路 ，先将队列 排满 ，然后对空闲出来的元素进行填充操作 ，找出当前队列最小的元素，进行出队，入队操作
  1.把一个窗口看成一个结构体，对窗口的数据进行维护，入队 和出队，入队时间(上一个节点出去了)和最晚出队时间(对时间进行累加操作)
  2. 定义结构体 
  struct node {
    int poptime, endtime; // poptime   上一个元素出队时间 endtime 窗口内所有元素结束时间
    queue<int> q;// m个元素的队列
};
3.对初始的n*m个元素进行入队操作
4. 对剩余的元素进行操作
   - 找到出队时间最早的元素
   - 对 队列中的第一个元素进行出队操作
          window[tempwindow].q.pop();// 弹出
        window[tempwindow].q.push(time[index]);、、添加
        window[tempwindow].poptime +=  window[tempwindow].q.front()//时间更新
 5. 进行遍历对结果进行输出
 使用一个合理的结构对数据进行操作的意义大于 维护多个变量 ，对元素进行遍历操作
 
   vector<bool> sorry(k + 1, false); // 用于判断元素是否超时
 
```

###  **1015** **Reversible Primes** 

```
1.  一个进行的转化操作和进行是否是质数的操作的拼接
错误的理解了题目的意思 ，这个数 进行 r 进行的反转操作 需要先转换成对应进行的数，然后进行反转操作
2.  bool isprime(int n) {
    if(n <= 1) return false;
    int sqr = int(sqrt(n * 1.0));
    for(int i = 2; i <= sqr; i++) {
        if(n % i == 0)
            return false;
    }
    return true;
}
 判断一个数是否为质数
 3. 简单的进制转化操作
```

